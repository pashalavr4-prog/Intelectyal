<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Реальная карта мира — Вороного на суше</title>
<style>
  html,body { margin:0; height:100%; background:#0b1d2a; font-family:Arial, sans-serif; }
  #map { width:100vw; height:100vh; cursor:grab; user-select:none; }
  #map:active { cursor:grabbing; }
  svg { display:block; width:100%; height:100%; }
  .vor-cell { stroke: rgba(8,40,16,0.9); stroke-width:0.4; }
  .land-outline { fill:none; stroke: rgba(255,255,255,0.12); stroke-width:0.8; pointer-events:none; }
  .controls { position: absolute; left:10px; top:10px; color:#fff; background: rgba(0,0,0,0.35); padding:8px; border-radius:6px; font-size:13px; }
  .controls label { display:inline-block; margin-right:8px; }
</style>
</head>
<body>

<div class="controls">
  <label>Ячеек (CELL_COUNT): <input id="cellCountInput" type="number" value="1500" min="100" max="8000" step="100" style="width:80px"></label>
  <button id="regenerateBtn">Перегенерировать</button>
  <span id="info" style="margin-left:10px"></span>
</div>

<div id="map">
  <svg id="svg" viewBox="0 0 1200 700" preserveAspectRatio="xMidYMid meet"
       xmlns="http://www.w3.org/2000/svg">
    <defs>
      <clipPath id="landClip" clipPathUnits="userSpaceOnUse"></clipPath>
      <!-- optional gradient or styles can be added here -->
    </defs>

    <!-- Group that will contain Voronoi cells; clipped to land -->
    <g id="voronoiGroup" clip-path="url(#landClip)"></g>

    <!-- Land outlines drawn on top -->
    <g id="landOutlineGroup" pointer-events="none"></g>
  </svg>
</div>

<!-- Libraries -->
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson-client@3/dist/topojson-client.min.js"></script>

<script>
(async function() {
  // Параметры и ссылки
  const TOPOJSON_URL = 'https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json'; // источник: world-atlas (Natural Earth). См. ссылки в ответе.
  const svg = d3.select('#svg');
  const width = +svg.attr('viewBox').split(' ')[2];
  const height = +svg.attr('viewBox').split(' ')[3];

  const vorGroup = svg.select('#voronoiGroup');
  const landClip = svg.select('#landClip');
  const landOutlineGroup = svg.select('#landOutlineGroup');

  const infoEl = document.getElementById('info');
  const cellCountInput = document.getElementById('cellCountInput');
  const regenBtn = document.getElementById('regenerateBtn');

  // Загрузка TopoJSON и преобразование в GeoJSON (land)
  const topo = await fetch(TOPOJSON_URL).then(r => r.json());
  const landGeo = topojson.feature(topo, topo.objects.land); // один FeatureCollection с полигонами суши

  // Проекция и path для отображения суши
  // Используем Меркатор; scale/translate подогнаны под viewBox
  const projection = d3.geoMercator()
                       .scale(190)         // можно подправить при необходимости
                       .translate([width / 2, height / 1.9]);
  const geoPath = d3.geoPath().projection(projection);

  // Отрисовать контуры суши в clipPath и как outline
  function renderLandShapes() {
    landClip.selectAll('path').remove();
    landOutlineGroup.selectAll('path').remove();

    // landGeo может быть FeatureCollection с несколькими Features (MultiPolygon/Polygon)
    landGeo.features.forEach((feat) => {
      const d = geoPath(feat);
      landClip.append('path').attr('d', d);
      landOutlineGroup.append('path').attr('d', d).attr('class', 'land-outline');
    });
  }

  // Генерация случайных точек строго внутри суши (в географических координатах)
  // Возвращает массив точек [lon, lat] длины <= count
  function generatePointsInsideLand(count, maxAttempts = 300000) {
    const bounds = d3.geoBounds(landGeo); // [[minLon,minLat],[maxLon,maxLat]]
    const minLon = bounds[0][0], minLat = bounds[0][1];
    const maxLon = bounds[1][0], maxLat = bounds[1][1];
    const points = [];
    let attempts = 0;

    while (points.length < count && attempts < maxAttempts) {
      attempts++;
      const lon = minLon + Math.random() * (maxLon - minLon);
      const lat = minLat + Math.random() * (maxLat - minLat);
      // d3.geoContains проверяет, лежит ли точка внутри FeatureCollection/Feature
      if (d3.geoContains(landGeo, [lon, lat])) {
        points.push([lon, lat]);
      }
    }
    return { points, attempts };
  }

  // Отрисовка Voronoi на основе точек (точки задаются в lon/lat, проецируем в экранные xy)
  function renderVoronoiFromGeoPoints(geoPoints) {
    vorGroup.selectAll('*').remove();
    const projected = geoPoints.map(p => projection(p)); // [[x,y],...]

    // если слишком мало точек — ничего не рисуем
    if (projected.length === 0) return;

    // Создаём Delaunay / Voronoi в экранных координатах
    const delaunay = d3.Delaunay.from(projected);
    const vor = delaunay.voronoi([0, 0, width, height]);

    // Рисуем все ячейки; если cellPolygon возвращает null — fallback вокруг точки
    const colorScale = d3.scaleSequential(t => {
      // простая вариативность: возвращаем HSL-ish зелёный
      const tnum = 40 + Math.round(t * 80);
      return `rgb(${20 + Math.round((1-t)*40)}, ${tnum}, ${20 + Math.round((1-t)*20)})`;
    });

    for (let i = 0; i < projected.length; i++) {
      let cell = vor.cellPolygon(i); // массив [x,y] или null
      let d;
      if (cell && cell.length) {
        d = 'M' + cell.map(p => p[0] + ',' + p[1]).join('L') + 'Z';
      } else {
        // резервный маленький прямоугольник вокруг точки чтобы не было дыр
        const px = projected[i][0], py = projected[i][1], r = 6;
        d = `M${px-r},${py-r}L${px+r},${py-r}L${px+r},${py+r}L${px-r},${py+r}Z`;
      }

      vorGroup.append('path')
        .attr('d', d)
        .attr('class', 'vor-cell')
        .attr('fill', colorScale(Math.random()))
        .attr('opacity', 0.98);
    }
  }

  // Главная функция: генерировать точки внутри суши и отрисовать
  async function generateAndRender(cellCount) {
    infoEl.textContent = 'Генерация точек…';
    // Сначала перерисовываем land clip (нужно до renderVoronoi, чтобы clipPath был готов)
    renderLandShapes();

    const { points, attempts } = generatePointsInsideLand(cellCount);
    infoEl.textContent = `Сгенерировано ${points.length} точек (попыток ${attempts}).`;
    // Проецируем и рендерим
    renderVoronoiFromGeoPoints(points);
  }

  // Инициализация UI и поведения
  renderLandShapes();
  // initial render
  await generateAndRender(+cellCountInput.value);

  regenBtn.addEventListener('click', async () => {
    const val = Math.max(100, Math.min(8000, +cellCountInput.value || 1500));
    cellCountInput.value = val;
    await generateAndRender(val);
  });

  // --- Пан/Зум (масштабирование относительно курсора и перетаскивание) ---
  let scale = 1, originX = 0, originY = 0;
  let isDragging = false, startX = 0, startY = 0;
  const root = document.getElementById('svg');

  // wheel zoom
  root.addEventListener('wheel', e => {
    e.preventDefault();
    const rect = root.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const factor = e.deltaY < 0 ? 1.12 : 0.88;
    const prevScale = scale;
    scale *= factor;

    // корректируем origin так, чтобы зум был относительно курсора
    originX = (originX - mx) * (scale / prevScale) + mx;
    originY = (originY - my) * (scale / prevScale) + my;

    // применяем transform к группам
    d3.select('#voronoiGroup').attr('transform', `translate(${originX},${originY}) scale(${scale})`);
    d3.select('#landOutlineGroup').attr('transform', `translate(${originX},${originY}) scale(${scale})`);
  }, { passive: false });

  // drag
  root.addEventListener('mousedown', e => {
    isDragging = true;
    startX = e.clientX - originX;
    startY = e.clientY - originY;
  });
  window.addEventListener('mouseup', () => { isDragging = false; });
  window.addEventListener('mousemove', e => {
    if (!isDragging) return;
    originX = e.clientX - startX;
    originY = e.clientY - startY;
    d3.select('#voronoiGroup').attr('transform', `translate(${originX},${originY}) scale(${scale})`);
    d3.select('#landOutlineGroup').attr('transform', `translate(${originX},${originY}) scale(${scale})`);
  });

})();
</script>
</body>
</html>
